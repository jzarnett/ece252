\input{configuration}

\title{Lecture 3 --- Operating System Structure; Traps }

\author{Jeff Zarnett \\ \small \texttt{jzarnett@uwaterloo.ca}}
\institute{Department of Electrical and Computer Engineering \\
  University of Waterloo}
\date{\today}


\begin{document}

\begin{frame}
  \titlepage

 \end{frame}

\begin{frame}
\frametitle{Operating System Structure}

An operating system is large and complex and this is not the sort of thing programmers create at a whim with no planning.

It is possible to write an OS without a defined structure. 

Like any large program, it will quickly become unmaintainable.

It will very likely be bug-riddled. 

\end{frame}

\begin{frame}
\frametitle{Traditional UNIX Structure}

\begin{center}
\includegraphics[width=0.8\textwidth]{images/layered-os.png}
\end{center}


\end{frame}

\begin{frame}
\frametitle{Layered Structure}

All the modern OSes tend to follow this structure, with modifications.

Another structural element within a layer: modules.

Just as we have classes and packages: modules group functionality.

Modules might be static, or loadable \& swappable.\\
\quad This might be during operation or with a reboot.

\end{frame}

\begin{frame}
\frametitle{Sun Solaris Structure}

\begin{center}
\includegraphics[width=0.8\textwidth]{images/solaris-structure.png}
\end{center}

Solaris supports loadable modules.

\end{frame}

\begin{frame}
\frametitle{Layered Operating System with Modules}

Provides the environment for the execution of programs.

Supports them in their execution by providing various services.

Some are there for convenience; others are mandatory.

\end{frame}

\begin{frame}
\frametitle{Layered Operating System with Modules}

\begin{center}
\includegraphics[width=0.9\textwidth]{images/os-structure.png}
\end{center}

\end{frame}


\begin{frame}
\frametitle{Layered Operating System with Modules}

Starting from the top:

\begin{itemize}
	\item User Interface
	\item System Calls
	\item Program Execution
	\item I/O Operations
	\item File Systems
	\item Communication
	\item Resource Allocation
	\item Accounting
	\item Error Detection
	\item Protection and Security
\end{itemize}


\end{frame}

\begin{frame}
\frametitle{Invoking System Calls}

Some services run automatically, without user intervention.

In other cases, we want specifically to invoke them. How?

It's a trap!

\end{frame}

\begin{frame}
\frametitle{Trap}

Operating systems run on the basis of interrupts.

A \alert{trap} is a software-generated interrupt.

Generated by an error (invalid instruction) or user program request.

\end{frame}

\begin{frame}
\frametitle{Trap}

If it is an error, the OS will decide what to do.\\
\quad Usual strategy: give the error to the program.

The program can decide what to do if it can handle it.\\
\quad Often times, the program doesn't handle it and just dies.

\end{frame}

\begin{frame}
\frametitle{User Mode and Kernel Mode}

Already we saw user mode vs. supervisor (kernel) mode instructions.

Supervisor mode allows all instructions and operations.

Even something seemingly simple like reading from disk or writing to console output requires privileged instructions. 

These are common operations, but they involve the OS every time.


\end{frame}

\begin{frame}
\frametitle{User Mode and Kernel Mode}

Modern processors track what mode they are in with the mode bit. 

At boot up, the computer starts up in kernel mode as the operating system is started and loaded. 

User programs are always started in user mode. 

When a trap or interrupt occurs, and the operating system takes over, the mode bit is set to kernel mode. 

When it is finished the system goes back to user mode before the user program resumes.


\end{frame}


\begin{frame}
\frametitle{Example: Text Editor Printing}

Suppose a text editor wants to output data to a printer.

\begin{center}
	\includegraphics[width=0.9\textwidth]{images/trap.png}
\end{center}

\end{frame}

\begin{frame}
\frametitle{User Mode and Kernel Mode: Motivation}

Why do we have user and supervisor modes, anyway? 

Uncle Ben to Spiderman: ``with great power comes great responsibility''. 

Same as why we have user accounts and administrator accounts. 

To protect the system \& its integrity against errant and malicious users.


\end{frame}

\begin{frame}
\frametitle{User Mode and Kernel Mode: Motivation}

Multiple programs might be trying to use the same I/O device at once.

Program~1 tries to read from disk. This takes some time.

If Program~2 wants to read from the same disk, the operating system forces Program~2 to wait its turn.

Without the OS, it would be up to the author(s) of Program~2 to check and wait patiently for it to become available. 

Works if everyone plays nicely.

Without enforcement of the rules, a program will do something nasty.

\end{frame}

\begin{frame}
\frametitle{User Mode and Kernel Mode: Motivation}

There is a definite performance trade-off.

Switching from user to kernel mode takes time.

The performance hit is worth it for the security.

\end{frame}

\begin{frame}
\frametitle{Example: Reading from Disk}
C code to perform a read on a UNIX system.

\texttt{read} takes three parameters: 
\begin{enumerate}
	\item the file name; 
	\item where to read the data to; and
	\item how many bytes to read.
\end{enumerate} 

\texttt{int bytesRead = read( filename, buffer, numBytes );}

Note that \texttt{read} returns the number of bytes successfully read.

\end{frame}


\begin{frame}
\frametitle{Example: Reading from Disk}

In preparation for a call to \texttt{read} the parameters are pushed on the stack.\\
\quad This is the normal way in which a procedure is called in C(++). 

\texttt{read} is called; the normal instruction to enter another function.

The \texttt{read} function will put its identifier in a predefined location.

Then it executes the \texttt{trap} instruction, activating the OS.

\end{frame}

\begin{frame}
\frametitle{Example: Reading from Disk}


The OS takes over and control switches to kernel mode. 

Control transfers to a predefined memory location within the kernel. 

The trap handler examines the request: it checks the identifier. 

Now it knows what system call request handler should execute: read. 

That routine executes. 

When it is finished, control will be returned to the \texttt{read} function.\\
\quad Exit the kernel and return to user mode.

\texttt{read} finishes and returns, and control goes back to the user program.


\end{frame}

\begin{frame}
\frametitle{System Call Summary}

The steps, arranged chronologically, when invoking a system call are:
\begin{enumerate}
	\item The user program pushes arguments onto the stack.
	\item The user program invokes the system call.
	\item The system call puts its identifier in the designated location.
	\item The system call issues the \texttt{trap} instruction.
	\item The OS responds to the interrupt and examines the identifier in the designated location.
	\item The OS runs the system call handler that matches the identifier.
	\item When the handler is finished, control exits the kernel and goes back to the system call (in user mode).
	\item The system call returns control to the user program.

\end{enumerate}


\end{frame}






\end{document}

